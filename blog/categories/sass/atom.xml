<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sass | Causes Engineering]]></title>
  <link href="http://causes.github.io/blog/categories/sass/atom.xml" rel="self"/>
  <link href="http://causes.github.io/"/>
  <updated>2014-01-03T11:29:53-08:00</updated>
  <id>http://causes.github.io/</id>
  <author>
    <name><![CDATA[Causes Engineers]]></name>
    <email><![CDATA[eng@causes.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sassy Progressive Enhancement]]></title>
    <link href="http://causes.github.io/blog/2013/11/29/sassy-progressive-enhancement/"/>
    <updated>2013-11-29T15:50:00-08:00</updated>
    <id>http://causes.github.io/blog/2013/11/29/sassy-progressive-enhancement</id>
    <content type="html"><![CDATA[<p>A mobile-first approach to design can be good: it helps you focus and
potentially simplify your requirements, which can translate into a better user
experience. Likewise, a mobile-first approach to implementation can be good: it
puts the more expensive tasks on the shoulders of clients that are more likely
to be able to handle the extra load, which can also translate to a better user
experience.</p>

<p>At <a href="https://www.causes.com">Causes</a>, we have been building things with a mobile-first approach both
in terms of design and implementation with a goal of progressive enhancement.
Since switching to this mode on the technical side, we have noticed that our
code is easier to write and more coherent to read, both of which are big
benefits for the engineering team.</p>

<p>So we&rsquo;ve put together a little project that helps us write readable media
queries in this way. We call it <a href="https://github.com/causes/sass-enhance">sass-enhance</a>.</p>

<!-- more -->


<h2>sass-enhance In Action</h2>

<p>sass-enhance defines mixins for media queries, <code>enhance</code> and <code>degrade</code>.</p>

<p>These mixins each take a breakpoint as an argument, and a block of styles to
apply when that breakpoint is activated. Optionally, you can specify ranged
breakpoints using <code>until</code>.</p>

<p>Breakpoints can be named, as defined in the <code>$breakpoint-max-widths</code> variable
(e.g. &ldquo;tablet&rdquo;), or arbitrary widths (e.g. &ldquo;720px&rdquo;).</p>

<h3><code>enhance()</code></h3>

<p>The <code>enhance</code> mixin is used to apply styles to a selector as the viewport gets
wider. It can be used to progressively enhance a page. We prefer using
<code>enhance</code> over <code>degrade</code> because it is a mobile-first implementation that tends
to be simpler in its execution.</p>

<p>To adjust the padding from 1em to 2em at the desktop breakpoint and wider, you
could use the following SCSS:</p>

<p>```scss
.my-selector {
  padding: 1em;</p>

<p>  @include enhance(desktop) {</p>

<pre><code>padding: 2em;
</code></pre>

<p>  }
}
```</p>

<p>Which compiles to:</p>

<p>```css
.my-selector {
  padding: 1em;
}</p>

<p>@media screen and (min-width: 960px) {
  .my-selector {</p>

<pre><code>padding: 2em;
</code></pre>

<p>  }
}
```</p>

<p>If you wanted to only apply a different amount of padding for only the tablet
viewport width and nothing wider or narrower, you could use the following SCSS:</p>

<p>```scss
.my-selector {
  padding: 1em;</p>

<p>  @include enhance(tablet until desktop) {</p>

<pre><code>padding: 2em;
</code></pre>

<p>  }
}
```</p>

<p>Which compiles to:</p>

<p>```css
.my-selector {
  padding: 1em;
}</p>

<p>@media screen and (min-width: 641px) and (max-width: 959px) {
  .my-selector {</p>

<pre><code>padding: 2em;
</code></pre>

<p>  }
}
```</p>

<h3><code>degrade()</code></h3>

<p>There are some cases where <code>enhance</code> does not work or make sense. In these
cases, it is okay to use <code>degrade</code> to gracefully degrade the styles as the
viewport gets narrower.</p>

<p>To adjust the padding from 2em to 1em at the tablet breakpoint and narrower,
you could use the following SCSS:</p>

<p>```scss
.my-selector {
  padding: 2em;</p>

<p>  @include degrade(tablet) {</p>

<pre><code>padding: 1em;
</code></pre>

<p>  }
}
```</p>

<p>Note: this produces functionally equivalent styles as the first example.</p>

<p>Likewise, if you wanted to only apply a different amount of padding for only
the tablet viewport width and nothing wider or narrower, you could use the
following SCSS:</p>

<p>```scss
.my-selector {
  padding: 2em;</p>

<p>  @include degrade(tablet until small-tablet) {</p>

<pre><code>padding: 1em;
</code></pre>

<p>  }
}
```</p>

<h2>Installation</h2>

<p>The recommended way to get set up with sass-enhance is via <a href="http://bower.io">Bower</a>, the
front-end package manager. To do this, simply run:</p>

<p><code>bash
bower install sass-enhance
</code></p>

<p>If your project uses Bower to manage its dependencies and you&rsquo;d like to save
sass-enhance as a dependency in your project&rsquo;s <code>bower.json</code> manifest file, add
the <code>--save</code> option:</p>

<p><code>bash
bower install --save sass-enhance
</code></p>

<p>Once you have the files locally, you simply need to import it so it is
available to your stylesheets. At Causes, we are building a Rails app, so we
symlink sass-enhance into <code>vendor/assets/stylesheets/sass-enhance/</code> and
<code>@import</code> it ear the top of our SCSS files:</p>

<p><code>scss
@import 'sass-enhance/sass-enhance';
</code></p>

<h2>Configuration</h2>

<p>Although sass-enhance will work just fine right out of the box, you may be
itching to configure it to fit your needs just right. For this purpose, we have
included a variable that you can set, called <code>$breakpoint-max-widths</code>. Just
make sure to set this variable <em>before importing sass-enhance</em> or your settings
will not work.</p>

<p>This variable is a comma separated list of breakpoint names and max-width
pairs. You can choose whatever names and widths you prefer. The default is
something like:</p>

<p>```scss
$breakpoint-max-widths: mobile           360px,</p>

<pre><code>                    mobile-landscape 500px,
                    small-tablet     640px,
                    tablet           959px,
                    desktop          99999px;
</code></pre>

<p>```</p>

<p>So, if you prefer media queries with more generic names, you are free to
configure it to suit your needs:</p>

<p>```scss
$breakpoint-max-widths: small  400px,</p>

<pre><code>                    medium 800px,
                    large  1000px;
</code></pre>

<p>```</p>

<h2>Conclusion</h2>

<p>We hope that you find this tool useful. Pull requests are welcome. <a href="https://github.com/causes/sass-enhance">View the
source on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Showing Color Chips from Sass Variables]]></title>
    <link href="http://causes.github.io/blog/2013/06/06/showing-color-chips-from-sass-variables/"/>
    <updated>2013-06-06T07:00:00-07:00</updated>
    <id>http://causes.github.io/blog/2013/06/06/showing-color-chips-from-sass-variables</id>
    <content type="html"><![CDATA[<p>At <a href="http://www.causes.com">Causes</a> we like to make our code more maintainable by building reusable
components. Part of this strategy includes <a href="http://joelencioni.com/blog/2013/03/16/10-easy-ways-to-craft-more-readable-css/#two-or-more-use-a-for">assigning variable names to hex
colors using Sass</a>. This allows us to more easily reuse the same colors
everywhere, which improves consistency and makes it easier to re-color the
entire site when our design needs change.</p>

<p>To increase the visibility of these reusable components, we&rsquo;ve been building
out a collection of things that designers and engineers can reference, drop in
to projects, and iterate upon. The code sits next to the rendered version,
allowing people to easily see the implementation required to produce the
result. We call this collection the component gallery. It helps us do more with
less code, be more consistent, and iterate on global changes more easily and
effectively.</p>

<p>When we started fleshing out the color variables we wanted to use throughout
the site, it seemed natural to show these colors in the component gallery as
Pantone color chips. That way, designers could reference the colors that we are
using, we&rsquo;d have a single place to see that all of the colors look great next
to each other, and engineers could easily pluck variable names when
implementing designs to match the mocks.</p>

<p><img src="/assets/2013-06-06-pantone-chips.png"></p>

<!-- more -->


<p>The quick solution would have had us defining these colors in two places: once
in Sass, where we actually need to use them, and again in Ruby, where we want
to render them on a page. However, we sensed that this would be a pain to
maintain and the two different definitions would quickly fall out of sync.</p>

<p>To resolve these issues, we decided to move our color variables into their own
Sass partial, and use Sass to parse it to display the colors and their
variables. Since we like to use <a href="http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html">functions like <code>darken()</code>, <code>lighten()</code>, and
<code>scale-color()</code></a>, we needed a solution that would actually execute the Sass
and use the result.</p>

<p>So we built a <a href="http://sass-lang.com/docs/yardoc/Sass/Tree/Visitors/Base.html">Sass Visitor</a> to evaluate variables and return pairs of names
and values:</p>

<p>```ruby
class SassVariableEvaluator &lt; Sass::Tree::Visitors::Base
  def visit_comment(node)</p>

<pre><code># prevents empty arrays from being in the returned array
</code></pre>

<p>  end</p>

<p>  def visit_variable(node)</p>

<pre><code>@environment ||= Sass::Environment.new
@environment.set_local_var(node.name, node.expr)
[node.name, node.expr.perform(@environment)]
</code></pre>

<p>  end
end
```</p>

<p>Then we have our <code>SassVariableEvaluator</code> visitor evaluate the variables in our
colors Sass partial:</p>

<p><code>ruby
def color_variables
  engine = Sass::Engine.for_file('path/to/_colors.css.scss', syntax: :scss)
  SassVariableEvaluator.visit(engine.to_tree).compact
end
</code></p>

<p>Looping over those evaluated variables in our view generates the desired
markup:</p>

<p>```haml
.clearfix
  &ndash; color_variables.each do |name, value|</p>

<pre><code>.pantone
  .chip{ style: "background-color: #{value};" }
  %var $#{name}
</code></pre>

<p>```</p>

<p>And style them nicely:</p>

<p>```sass
.pantone {
  @include box-shadow(0 0 5px rgba(0, 0, 0, .1));
  border: 1px solid #eee;
  float: left;
  font-size: 11px;
  margin: 0 1em 1em 0;
  width: 145px;</p>

<p>  &amp;:nth-child(4n) {</p>

<pre><code>margin-right: 0;
</code></pre>

<p>  }</p>

<p>  .chip {</p>

<pre><code>background: #f00;
height: 145px;
</code></pre>

<p>  }</p>

<p>  var {</p>

<pre><code>display: block;
font-style: normal;
font-weight: bold;
height: 40px;
padding: .75em;
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 Easy Ways to Craft More Readable CSS]]></title>
    <link href="http://causes.github.io/blog/2013/03/16/10-easy-ways-to-craft-more-readable-css/"/>
    <updated>2013-03-16T15:45:00-07:00</updated>
    <id>http://causes.github.io/blog/2013/03/16/10-easy-ways-to-craft-more-readable-css</id>
    <content type="html"><![CDATA[<blockquote><p>Always code as if the [person] who ends up maintaining your code will be a
violent psychopath who knows where you live. Code for readability.
—<cite><a href="https://groups.google.com/d/msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ">John Woods</a></cite></p></blockquote>

<p>Diving into a large, old piece of CSS typically is neither easy nor
pleasurable. I find that <strong>the biggest challenges in working with old CSS often
lie in understanding the purpose and interactions of the styles</strong>.</p>

<p>When styling new elements, we have the entire context of the implementation
immediately available, and it is easy to write styles that make sense to us at
that very moment. However, in a few weeks or to a fresh pair of eyes, what made
a lot of sense at first might end up being a lot more cryptic. Without a clear
understanding of the purpose and interactions of the styles, modifying
stylesheets can be dangerous, tedious, and cumbersome. Therefore, it is
important to communicate enough context so that future developers will be able
to grok the code easily and make informed decisions.</p>

<p>At <a href="http://www.causes.com/">Causes</a>, we have adopted the following practices
which we believe have improved the maintainability of our stylesheets, reduced
bugs, and increased developer velocity. When you have finished reading this, I
hope that you will have a few more tools to help move your codebase toward
greater maintainability.</p>

<p><a class="more-link" href="http://joelencioni.com/blog/2013/03/16/10-easy-ways-to-craft-more-readable-css/">Read on</a></p>
]]></content>
  </entry>
  
</feed>
