<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | Causes Engineering]]></title>
  <link href="http://causes.github.io/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://causes.github.io/"/>
  <updated>2014-02-19T17:12:30-08:00</updated>
  <id>http://causes.github.io/</id>
  <author>
    <name><![CDATA[Causes Engineers]]></name>
    <email><![CDATA[eng@causes.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Four Styles of Function Organization]]></title>
    <link href="http://causes.github.io/blog/2013/09/11/four-styles-of-object-organization/"/>
    <updated>2013-09-11T13:48:00-07:00</updated>
    <id>http://causes.github.io/blog/2013/09/11/four-styles-of-object-organization</id>
    <content type="html"><![CDATA[<p>In object-oriented code, there are several choices for where to put a
new function, and each choice has its pros and cons.  These choices
repeat themselves over and over in a codebase, so it&rsquo;s worth reviewing
the tradeoffs we make on a daily basis.</p>

<!-- more -->


<h2>Methods directly on core models</h2>

<p>In <abbr title="Object Oriented Programming">OOP</abbr> frameworks
like Rails, a method&rsquo;s default home is the class that holds its state.
Suppose that the <code>User</code> class has Facebook friends, Twitter followers,
and LinkedIn connections.  The simplest approach is:</p>

<p>```ruby
class User
  def facebook_friends; &hellip;; end
  def twitter_followers; &hellip;; end
  def linkedin_connections; &hellip;; end
end</p>

<h1>invocation is:</h1>

<p>user.facebook_friends()
```</p>

<p>The pros of this arrangement are its simplicity and obviousness.  All of
the methods on <code>User</code> can be found explicitly listed in the <code>user.rb</code>
file.</p>

<p>The problem with putting everything in one model is that eventually it
contains many inessential features.  The pathological case looks like:</p>

<p><code>ruby
class User
  def facebook_method0; ...; end
  def facebook_method1; ...; end
  def facebook_method2; ...; end
  def twitter_method0; ...; end
  def twitter_method1; ...; end
  def twitter_method2; ...; end
  def linkedin_method0; ...; end
  def linkedin_method1; ...; end
  def linkedin_method2; ...; end
end
</code></p>

<p>This is the <strong>obese model</strong> problem.  Too much code in one model and
too little organization makes a monolithic <code>User</code> class a poor unit of
organization.  An obese class is hard to understand because it contains
too much unstructured code inside it.  Consumers of obese classes are
also harder to understand, because the dependency between the consumer
and the consumed is defined in terms of a large, imprecise concept (the
obese model), rather than a small and precise one.</p>

<p>Putting methods directly into core models is a simple, direct and
default solution that works well for small situations.  By the
<a href="http://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>
principle, it is probably still the best place to start.  However for
large projects, the downsides of this organization start to show.</p>

<p>In Ruby-land, a proliferation of concerns inside an object often leads
to a second style of code organization: mixins.</p>

<h2>Mixins</h2>

<p>Ruby supports mixins as a form of code reuse and concise organization.
Mixins declare code separately and then include them directly into
another class.  For example:</p>

<p>```ruby
module Facebook
  def facebook_method0; &hellip;; end
  def facebook_method1; &hellip;; end
  def facebook_method2; &hellip;; end
end</p>

<p>class User
  include Facebook
end</p>

<h1>invoking:</h1>

<p>user.facebook_method0()
```</p>

<p>Mixins can improve both organization and code reuse.  In this example,
the Facebook-related methods are grouped together in one place, and
separated out from <code>User</code>.  The <code>Facebook</code> module can then be mixed into
a variety of other classes.  In this organization, the pros are that the
related methods are grouped into one place (the <code>Facebook</code> module),
keeping both the individual concern and the target class (<code>User</code>)
cleaner.</p>

<p>The first problem with mixins is that <code>User</code> objects now have methods
that cannot be found directly in <code>User</code>.  In order to figure out how
<code>User</code> got <code>facebook_method0</code>, and what <code>facebook_method0</code> does, you
can&rsquo;t see it by looking at <code>User</code>; you have to realize it&rsquo;s getting
<code>include</code>d, usually by grepping the entire codebase for
<code>facebook_method0</code> <a href="#notes">&#91;1&#93;</a>, which is unfortunate.  This
dislocation also increases the chances of method name collision
between the mixin and the host class.</p>

<p>A second problem with mixins is that they tend to have mysterious and
implicit dependencies upon their host classes, especially if they were
first written coupled-into the host, and then extracted without
generalizing.  Mixins used only once are particularly prone to this
&ldquo;separation is not organization&rdquo; problem.</p>

<p>From the outside, the mixin solution looks structurally identical to
just putting all the methods in the object: you see an object with a
ton of methods on it.  Thus mixin solutions share basic properties
with a large model, but with a tradeoff:</p>

<ul>
<li>Better organization of a single concern into a single place</li>
<li>Some code reusability</li>
<li>Worse clarity on where methods are coming from</li>
<li>Often worse clarity on code flow, since mixin methods are interacting
with base class methods, and you&rsquo;ll find yourself ping-ponging between
reading the two files.</li>
</ul>


<p>Mixins can make code more concise, and somewhat better organized, but
often at the cost of the code being much less clear.</p>

<p>Mixins often prompt people to turn to <em>delegation</em>.</p>

<h2>Delegation</h2>

<p>Because mixins are sometimes frustratingly invisible, we also see
people take an opposing approach: explicitly delegating functionality
to underlying objects.  The separately concerned functionality goes
into its own class/module.  For example:</p>

<p>```ruby
module Facebook
  def self.method0(user); &hellip;; end
  def self.method1(user); &hellip;; end
  def self.method2(user); &hellip;; end
end</p>

<h1>basic delegation</h1>

<p>class User
  def facebook_method0</p>

<pre><code>Facebook.method0(self)
</code></pre>

<p>  end</p>

<p>  def facebook_method1</p>

<pre><code>Facebook.method1(self)
</code></pre>

<p>  end</p>

<p>  def facebook_method2</p>

<pre><code>Facebook.method2(self)
</code></pre>

<p>  end
end</p>

<h1>invoking:</h1>

<p>user.facebook_method0()
```</p>

<p>The strength of this organization is that the individual <code>Facebook</code>
concern is clearly organized into its own module, and explicitly
called from <code>User</code>.  This improves organization, reusability, and
simplicity of the execution path.  One downside is that <code>User</code> is back
to having every possible method within it, though most of them are
mere portals to the separate module.</p>

<p>From the outside the <code>User</code> class still looks the same: it has a ton of
methods on it.  So the cons for this style of organization remain mostly
the same as the original &ldquo;shove all the methods in the class.&rdquo;  On the
plus side, there is slightly less complexity inside <code>User</code> itself,
because some has been separated out into <code>Facebook</code>.</p>

<p>This is a verbose but somewhat clearer organization of the code&mdash;if
you like delegation, there are several slightly less verbose
approaches available <a href="#notes">&#91;2&#93;</a>.  But delegation&rsquo;s
verbosity and continued coupling of everything into <code>User</code> still call
out for a better alternative.</p>

<h2>Namespaces</h2>

<p>The persistent problem above is dealing with peripheral functionality
such as <code>Facebook</code> coupled into core functionality such as <code>User</code>.  Even
if internally a class has been cleaned up to only delegate methods, the
external complexity of the class has not improved: consumers of <code>User</code>
still see a sprawling and complex interface of functions.</p>

<p>We can clean up massive classes to have smaller and more specialized
interfaces, by splitting up concerns into namespaces like this:</p>

<p>```ruby
module Facebook
  def self.method0(user); &hellip;; end
  def self.method0(user); &hellip;; end
  def self.method0(user); &hellip;; end
end</p>

<p>class User
end</p>

<h1>invoking</h1>

<p>Facebook.method0(user)
```</p>

<p>The most important part of this arrangement is that instead of methods
being inside <code>User</code>, they&rsquo;re called from the outside, from <code>Facebook</code>,
which takes a user.</p>

<p>The pros of this organization are that the separate concern (of
Facebook, of Twitter, etc.) has finally truly been extracted out of
<code>User</code>.  There is no crowding inside <code>User</code>, no implicit method
declarations, and all of the code for Facebook is inside the <code>Facebook</code>
module.</p>

<p>This addresses most of the original concerns.  The disadvantage in
this situation are that this could eventually proliferate into many
fragmented modules, and that there is no longer a single home for for
user-related method declarations.</p>

<p>Using namespaces has a variety of structural advantages, which we&rsquo;ll
treat in a different article.  For now we hope to have shown that,
strictly for basic comprehension, there are tradeoffs worth
considering for consolidating vs. separating code.</p>

<h2>Conclusion</h2>

<p>Code organization choices are deceptively mundane: they seem like
small decisions, but have compounding long term impacts on the
malleability of our code.  Because we think and talk in terms of code,
clear code help us understand clearly, move quickly and reason
correctly.  This makes organization a fundamental investment we can
make in our software.</p>

<h2>Notes</h2>

<p><a name="notes"></a></p>

<p>&#91;1&#93; You can also find a method definition via</p>

<pre><code>my_object.method(:my_method_name).source_location
</code></pre>

<p>&#91;2&#93; There are terser delegation patterns; Rails comes with a
  <code>delegate</code> method, and the Ruby standard lib has a <code>Delegator</code>
  class, a <code>SimpleDelegator</code> class, a <code>Forwardable</code> module, which can
  all be used for various styles of delegation.</p>

<p>Special thanks to Andrew Berls, Jeremy Dunck, Preston Guillory, Greg
Hurrell,  Joe Lencioni, and Nebs Petrovic for their thoughts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing side-effects with the Pub-Sub model]]></title>
    <link href="http://causes.github.io/blog/2013/08/08/managing-side-effects-with-the-publish-subscribe-model/"/>
    <updated>2013-08-08T10:00:00-07:00</updated>
    <id>http://causes.github.io/blog/2013/08/08/managing-side-effects-with-the-publish-subscribe-model</id>
    <content type="html"><![CDATA[<p>Over time, large-scale object-oriented systems tend to produce <a href="http://en.wikipedia.org/wiki/God_object">God
Objects</a>. These are classes which know
too much or do too much. They have connections to disparate and varied parts of
the system. They depend on everything, and everything depends on them. They make
systems slow to work with, intractable and hard to modify. They insidiously
undermine and resist our efforts to carry out our core task as engineers:
decomposing complex problems into smaller subproblems that are more easily
solved.</p>

<p>At <a href="http://www.causes.com">Causes</a> there are some concepts that are
front-and-center in our product: users, their campaigns and the actions
they create to make an impact (things like petitions, fundraisers and pledges).
The concepts are so core that they have a tendency to become God Objects unless
we diligently work to prevent them accruing more and more functionality.</p>

<p>We&rsquo;ve lately applied the
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Pub-Sub</a>
(Publish-Subscribe) model to our Ruby code, applying the familiar event-based
patterns that we know from JavaScript to the server side, in an effort to reduce
the tight coupling that some of these God Objects have to other parts of the
system. With a simple, framework-agnostic Ruby library, we&rsquo;ve been able to
significantly tame some of the complexity around these classes, and we&rsquo;ve
released it as a Ruby gem, <a href="https://github.com/causes/pubsubhub">PubSubHub</a>.</p>

<!-- more -->


<h2>A case study in managing side-effects: taking action</h2>

<p>When a user takes action on our site by, say, signing a petition, there is
potentially a slew of side-effects:</p>

<ul>
<li>we persist a record of the signature to a <code>signatures</code> table in the
database, and an <code>ActionCredit</code> (effectively a hundreds-of-millions-of-rows
journal of all action-taking activity on our site)</li>
<li>counter-caches tick up</li>
<li>stats events are generated and dispatched to one or more tracking systems</li>
<li>a recruiter may receive an on-site notification or an email</li>
<li>invitations may be marked as accepted (in the case of the recruiter) or
&ldquo;indirectly accepted&rdquo; (in the case of other, multiple inviters)</li>
<li>Facebook Request objects may be cleared out</li>
<li>feed events are generated and propagated to feeds</li>
<li>a custom <a href="https://developers.facebook.com/docs/opengraph/">Open Graph</a>
action is published</li>
<li>if the action pushed the campaign over a milestone, a milestone event may be
generated, which itself could result in feed events being propagated, onsite
notifications, and an email to the campaign organizer</li>
<li>if the action is sponsored by a brand, the signature could trigger a
donation to a nonprofit (which itself would have other side-effects)</li>
</ul>


<p>And this is only scratching the surface. Having the <code>Action</code> class know about
all these collaborators effectively makes it depend on them just as much as they
depend on it, and it places the class squarely within &ldquo;God Object&rdquo; territory.</p>

<h2>Using PubSubHub</h2>

<p>With <code>PubSubHub</code> we have a centralized registry of events, together with the
listeners that wish to be informed of those events. Our <code>Action</code> class now just
has to make a call to <code>PubSubHub.trigger</code> to let its collaborators know that
something important happened:</p>

<p>```ruby
def take_action(user, recruiter, options = {})
  # core action-taking mechanics go here&hellip;</p>

<p>  # and secondary side-effects occur as a result of&hellip;
  PubSubHub.trigger :took_action, self, metadata
end
```</p>

<p>This greatly reduces the clutter and makes the separation between core mechanics
and secondary side-effects clear.</p>

<p>Listener registration looks like this:</p>

<p>```ruby
PubSubHub.register(
  took_action: [</p>

<pre><code>{ listener: AlertBanner,                  async: false },
{ listener: FacebookRequest,              async: true  },
{ listener: InvitationManager,            async: false },
{ listener: Profile,                      async: true  },
{ listener: StatsManager,                 async: true  },
{ listener: AnalyticsManager,             async: false },
{ listener: Campaign,                     async: false },
{ listener: NotificationDistributor,      async: false },
# etc ...
</code></pre>

<p>  ],
  # other event types here&hellip;
)
```</p>

<p>We considered making listener registration more distributed, via a DSL that
could be sprinkled into other classes, but in the end having the central
registry provides us with a nice inventory of the relationships and dependencies
between different parts of the system. It also conveniently avoids load-order
issues in the context of a large Rails app, whose loading behavior (eager vs
lazy, cached vs uncached) is different between development and production; we
can just stick the registration in an initializer and be done with it.</p>

<p>Note that with this change we&rsquo;ve inverted the dependencies such that the
all-important <code>Action</code> class no longer depends on a bunch of other classes;
rather, those other classes depend on it. From the perspective of the <code>Action</code>
class, this is a good thing: if your goal is to build something that is both
robust and useful, depending on as little as possible and having others depend
on you is a good thing.</p>

<p>One other nicety of this system is that it gives us a straight-forward way to
divide side-effects into the urgent and the non-urgent, the latter being run
asynchronously.</p>

<p>The final piece of the puzzle are the various listeners. By convention, they
implement a handler of the form <code>handle_&lt;event_name&gt;</code>:</p>

<p>```ruby
def handle_took_action(action, metadata)
  return unless campaign = action.campaign
  return unless user     = metadata[:user]</p>

<p>  Follow.where(followed_id:   campaign,</p>

<pre><code>           followed_type: Campaign,
           user_id:       user).first_or_create!
</code></pre>

<p>end
```</p>

<h2>Next steps</h2>

<p>This slender little library has allowed us to scoop out a lot of functionality
from our <code>Action</code> class, making it significantly less god-like. New engineers
are able to arrive in the implementation file for the first time and comprehend
the core structure and functionality more rapidly, free from the distraction of
a bunch of secondary and tertiary side-effects.</p>

<p>If you&rsquo;d like to see what PubSubHub can do for your code base, it&rsquo;s only a <code>gem
install pubsubhub</code> away, and the <a href="https://github.com/causes/pubsubhub">source
code</a> is up on GitHub.</p>

<p>We&rsquo;re mindful that to the person with a hammer, everything looks like a nail, so
we&rsquo;re careful to ensure that we use the tool judiciously. In the context of a
Rails application, this means that we continue to make use of Rails' built-in
tools for managing side effects (things like <a href="http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html">Active Record life-cycle
callbacks</a>,
<a href="https://github.com/rails/rails-observers">observers</a>, and <a href="http://api.rubyonrails.org/classes/ActiveSupport/Notifications.html">Active Support
Notifications</a>).</p>

<p>Additionally, our eyes are ever on the prize, asking the question, &ldquo;How can we
make this simpler?&rdquo; The Pub-Sub pattern is a tool for loosening the coupling
between parts of the system, but it does not entirely eliminate that coupling.
<a href="http://firstround.com/article/The-one-cost-engineers-and-product-managers-dont-consider">Complexity</a>
is the ultimate enemy, and the best way to manage side-effects is to simply
eliminate them in the first place.</p>
]]></content>
  </entry>
  
</feed>
